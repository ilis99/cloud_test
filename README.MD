# Тестовое задание на стажировку AppSecCloudCamp

На выполнение тестового задания у вас есть 7 дней. 
Выполненное задание следует опубликовать на GitHub и отправить на почту **appseccloudcamp@cloud.ru**. Практическое задание состоит из нескольких частей, при этом, даже если вы сделали только одну часть задания - присылайте её на рассмотрение. 
**ВАЖНО** При отправке тестового задания на почту обязательно указывайте ваши фамилию, имя, контактный номер телефон, telegram (при его наличии)

## 1. Вопросы для разогрева

1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?

   *Являюсь студентом магистратуры ВМК МГУ по направлению кибербезопасность. Моя курсовая и дипломная заключаются в решении задач по обеспечению кибербезопасности при проектировании и разработке приложений на базе микросервисной архитектуры. Я пишу свой учебный проект, используя flask. Также до этого писал учебное приложение на Django, реализовывая популярные уязвимости IDOR,XSS,SQLi и т.п. Потом соответственно предлагал решения по устранению уязвимостей(например, ORM для SQLi). Также в рамках обучения проводил аудит безопасности, немного поработав с ELK стеком*. 

2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?

   *Security code review и моделирование угроз подразумевает ручной статический анализ кода. В рамках своего проекта на Django я анализировал код на наличие уязвимостей, таких как SQL-инъекции, XSS, IDOR и других.*

3. Если у вас был опыт поиска уязвимостей, расскажите, как это было?

   *Изучал Burp Suite в рамках выполнения лабораторных на portswigger(DAST). С SAST познакомился в гитлабе(у них встроенный инструмент), соответсвенно Django проект проверял на гитлабе.*

4. Почему вы хотите участвовать в стажировке?
   
   *Я хочу участвовать в стажировке, потому что мне нравится данная сфера и моя дипломная тесно связана с AppSec. Вижу огромный потенциал в области кибербезопасности. Я новичок в этой сфере, для меня это огромная возможность вырасти как специалист и стать отличным сотрудником в вашей компании. Обучение на реальных задачах мне очень поможет узнать, как все это работает в коммерческих масштабах, а не на localhost'е. Я весьма упертый человек и много могу своим желанием узнать и добиться. Под грамотным управлением я очень быстро прогрессирую, и хочу это продемонстровать.*

---

## 2. Security code review

### Часть 1. Security code review: GO

```
query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
```

Явная SQL-инъекция. Тут используется шаблон, в который напрямую вставляется searchQuery. Банально пишем 'OR 1=1--, вот у нас уже все строки из таблицы выведутся. На самом деле можно удалить, изменить данные из БД. Чтобы решить данную проблему, нужно использовать параметризованные запросы(обрабатывает ввод и не дает интерпретировать как SQL запрос), или фильтрация символов(не самое лучшее решение), или использовать подготовленные строки для безопасной вставки. Также ORM как решение, но у ORM скорость довольно низкая.

```
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "github.com/go-sql-driver/mysql"
)

var db *sql.DB
var err error

func initDB() {
    db, err = sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        log.Fatal(err)
    }

err = db.Ping()
if err != nil {
    log.Fatal(err)
    }
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }

searchQuery := r.URL.Query().Get("query")
if searchQuery == "" {
    http.Error(w, "Query parameter is missing", http.StatusBadRequest)
    return
}

query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
if err != nil {
    http.Error(w, "Query failed", http.StatusInternalServerError)
    log.Println(err)
    return
}
defer rows.Close()

var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}

fmt.Fprintf(w, "Found products: %v\n", products)
}

func main() {
    initDB()
    defer db.Close()

http.HandleFunc("/search", searchHandler)
fmt.Println("Server is running")
log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### Часть 2: Security code review: Python

**Пример 2.1**

```
output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
```

Jinja2 — это инструмент для html-шаблонизации. Он позволяет подставлять переменные из Python прямо на странички в браузере.
name и age это переменные, взятые из запроса(может быть просто какая-то простенькая форма с двумя полями: возраст и имя). 
Значит можно теоретически провести Reflected XSS-атаку(то есть отраженную). В name пишем <script>alert(1);</script> и при рендере у нас выпрыгнет окошко алерт. Злоумышленник может написать более комплексный JavaScript-код, который может выполнять те или иные действия от лица текущего пользователя.
Чтобы исправить данную уязвимость, нужно проверять ввод(если число ожидается, то проверить, что написано именно число) и кодировать управляющие HTML-символы, JavaScript перед отображением в браузере(у них разные кодировки, это самое лучшее решение имхо). Можно поставить HttpOnly куку, которая не даст запускать какие-либо скрипты.

**Пример кода №2.1**
```
from flask import Flask, request
from jinja2 import Template

app = Flask(name)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
return output

if name == "main":
    app.run(debug=True)
```
**Пример 2.2**

```
cmd = 'nslookup ' + hostname
output = subprocess.check_output(cmd, shell=True, text=True)
```

Создается конкатенация команды и строки с именем хоста. Это похоже на OS Command Injection. Впринципе после разделяющего символа(например, & дает нам возможность запустить еще команды whoami, ps и т.п.). Общими словами можно выполнить команды на сервере, которые могут сильно навредить. Чтобы исправить данную уязвимость, нельзя явно вызывать команды операционной системы, вместо этого использовать API. Также можно использовать белый список значений, проверять отсутствие специальных символов.

```
from flask import Flask, request
import subprocess

app = Flask(name)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
return output
if name == "main":
    app.run(debug=True)
```

## 3. Моделировани угроз

Изучите диаграмму потоков данных (Data Flow Diagram, DFD) сервиса, обеспечивающего отправку информации в Telegram и Slack:

![DFD](https://github.com/appseccloudcamp/test-assignment/blob/main/test-dfd.png)

Краткое описание компонентов сервиса:
 - **User** - авторизованный пользователь системы. Может настраивать отправку уведомлений и загружать изображения для дальнейшего использования при отправке уведомлений;
 - **Microfront** - микрофронт, которые позволяет взаимодействовать с сервисом отправки информации;
 - **Backend application** - набор микросервисов реализующих бизнес-логику приложения и обеспечивающих взаимодействие со всеми внешними сервисами;
 - **Auth** - сервис отвечающий за аутентификацию и авторизацию клиентов сервиса отправки информации;
 - **S3** - объектное хранилище, предназначенное для хранения статического контента сервиса отправки информации;
 - **PostgreSQL** - база данных, предназначенная для хранения пользовательских конфигураций сервиса отправки информации.    

Проанализируйте диаграмму потоков данных приложения и ответьте на следующий вопросы:
Будем считать, что мы рассматриваем в рамках STRIDE.
 - Расскажите, какие потенциальные проблемы безопасности существуют для данного сервиса?

1)Хранение статического контента: Information Disclosure. Потенциально реализовать IDOR, который позволит нам получить к другим статическим файлам. Например, если мы все храним в папке upload и обращаемся к файлу, указывая путь, то есть вероятность, что мы можем получить доступ к файлам при отсутствии должных проверок.

2)PostgreSQL: Tampering. Изменения в конфиге веб приложения, могут привести к отключению некоторых политик безопасности.

3)Auth: Spoofing. Так как сервис Auth не взаимодействует напрямую с User(отсутствует DataFlow между ними), то есть возможность перехватить данные User в бэкенде приложения. Это даст доступ к учетной записи.

 - Расскажите, к каким последствиям может привести эксплуатация проблем, найденных вами?

1)Несанкционированный доступ к файлам.

2)Security Misconfiguration

3)Доступ к сервису с чужого аккаунта

 - Расскажите, какие способы исправления уязвимостей и смягчения рисков вы можете предложить по отмеченным вами проблемам безопасности

1)https для безопасной передачи данных(ника и пароля)

2)Взаимодействие с сервисом аутентификации и авторизации напрямую.

3)Принцип Zero Trust.

4)Единый механизм контроля доступа во всем приложении.

 - Напишите список уточняющих вопросов, которые вы бы задали разработчикам данного сервиса?

1)Как происходит взаимодействие бэкэнда с сервисом авторизации и аутенификации?

2)Какие меры защиты у БД?

3)Какие политики безопасности существуют?

4)Какую информацию получают Slack и Telegram? Есть ли там что-то конфиденциальное?
